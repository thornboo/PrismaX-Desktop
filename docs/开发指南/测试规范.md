# 测试规范

> 本文档描述 PrismaX 项目的测试策略与规范

---

## 概述

PrismaX 采用多层次测试策略，确保代码质量和功能稳定性。

---

## 测试金字塔

```
                    /\
                   /  \
                  / E2E \
                 /  测试  \
                /----------\
               /   集成测试   \
              /----------------\
             /      单元测试      \
            /----------------------\
```

| 测试类型 | 占比 | 执行频率 | 执行时间 |
|----------|------|----------|----------|
| 单元测试 | 70% | 每次提交 | 秒级 |
| 集成测试 | 20% | 每次 PR | 分钟级 |
| E2E 测试 | 10% | 每日/发布前 | 分钟级 |

---

## 测试工具

| 工具 | 用途 |
|------|------|
| Vitest | 单元测试、集成测试 |
| Playwright | E2E 测试 |
| Testing Library | React 组件测试 |
| MSW | API Mock |
| Faker | 测试数据生成 |

---

## 单元测试

### 文件命名

```
src/
├── utils/
│   ├── format.ts
│   └── format.test.ts      # 单元测试文件
├── hooks/
│   ├── useChat.ts
│   └── useChat.test.ts
```

### 测试结构

```typescript
// format.test.ts
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { formatDate, formatFileSize, truncateText } from './format';

describe('formatDate', () => {
  beforeEach(() => {
    // 固定时间，确保测试稳定
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2024-01-15T10:00:00Z'));
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should format date in default format', () => {
    const date = new Date('2024-01-15T08:30:00Z');
    expect(formatDate(date)).toBe('2024-01-15 08:30');
  });

  it('should format date with custom format', () => {
    const date = new Date('2024-01-15T08:30:00Z');
    expect(formatDate(date, 'YYYY/MM/DD')).toBe('2024/01/15');
  });

  it('should handle invalid date', () => {
    expect(formatDate(new Date('invalid'))).toBe('Invalid Date');
  });

  it('should show relative time for recent dates', () => {
    const fiveMinutesAgo = new Date('2024-01-15T09:55:00Z');
    expect(formatDate(fiveMinutesAgo, 'relative')).toBe('5 minutes ago');
  });
});

describe('formatFileSize', () => {
  it.each([
    [0, '0 B'],
    [1023, '1023 B'],
    [1024, '1 KB'],
    [1536, '1.5 KB'],
    [1048576, '1 MB'],
    [1073741824, '1 GB'],
  ])('should format %i bytes as %s', (bytes, expected) => {
    expect(formatFileSize(bytes)).toBe(expected);
  });

  it('should throw for negative values', () => {
    expect(() => formatFileSize(-1)).toThrow('Invalid file size');
  });
});

describe('truncateText', () => {
  it('should not truncate short text', () => {
    expect(truncateText('Hello', 10)).toBe('Hello');
  });

  it('should truncate long text with ellipsis', () => {
    expect(truncateText('Hello World', 8)).toBe('Hello...');
  });

  it('should handle empty string', () => {
    expect(truncateText('', 10)).toBe('');
  });
});
```

### 异步测试

```typescript
// api.test.ts
import { describe, it, expect, vi } from 'vitest';
import { fetchUserData, createConversation } from './api';

describe('fetchUserData', () => {
  it('should fetch user data successfully', async () => {
    const mockUser = { id: '1', name: 'Test User' };
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockUser),
    });

    const result = await fetchUserData('1');

    expect(result).toEqual(mockUser);
    expect(fetch).toHaveBeenCalledWith('/api/users/1');
  });

  it('should throw error on failed request', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 404,
    });

    await expect(fetchUserData('999')).rejects.toThrow('User not found');
  });

  it('should handle network error', async () => {
    global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));

    await expect(fetchUserData('1')).rejects.toThrow('Network error');
  });
});
```

### Mock 使用

```typescript
// service.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ChatService } from './chat-service';
import { AIProvider } from './ai-provider';

// Mock 模块
vi.mock('./ai-provider', () => ({
  AIProvider: vi.fn().mockImplementation(() => ({
    chat: vi.fn(),
    stream: vi.fn(),
  })),
}));

describe('ChatService', () => {
  let chatService: ChatService;
  let mockProvider: AIProvider;

  beforeEach(() => {
    vi.clearAllMocks();
    mockProvider = new AIProvider();
    chatService = new ChatService(mockProvider);
  });

  it('should send message and return response', async () => {
    const mockResponse = { content: 'Hello!' };
    vi.mocked(mockProvider.chat).mockResolvedValue(mockResponse);

    const result = await chatService.sendMessage('Hi');

    expect(mockProvider.chat).toHaveBeenCalledWith([
      { role: 'user', content: 'Hi' },
    ]);
    expect(result).toEqual(mockResponse);
  });
});
```

---

## 组件测试

### React 组件测试

```typescript
// ChatInput.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ChatInput } from './ChatInput';

describe('ChatInput', () => {
  it('should render input field', () => {
    render(<ChatInput onSend={vi.fn()} />);

    expect(screen.getByPlaceholderText('Type a message...')).toBeInTheDocument();
  });

  it('should call onSend when submit button clicked', async () => {
    const onSend = vi.fn();
    render(<ChatInput onSend={onSend} />);

    const input = screen.getByPlaceholderText('Type a message...');
    await userEvent.type(input, 'Hello');

    const submitButton = screen.getByRole('button', { name: /send/i });
    await userEvent.click(submitButton);

    expect(onSend).toHaveBeenCalledWith('Hello');
  });

  it('should call onSend when Enter pressed', async () => {
    const onSend = vi.fn();
    render(<ChatInput onSend={onSend} />);

    const input = screen.getByPlaceholderText('Type a message...');
    await userEvent.type(input, 'Hello{enter}');

    expect(onSend).toHaveBeenCalledWith('Hello');
  });

  it('should not submit empty message', async () => {
    const onSend = vi.fn();
    render(<ChatInput onSend={onSend} />);

    const submitButton = screen.getByRole('button', { name: /send/i });
    await userEvent.click(submitButton);

    expect(onSend).not.toHaveBeenCalled();
  });

  it('should clear input after submit', async () => {
    const onSend = vi.fn();
    render(<ChatInput onSend={onSend} />);

    const input = screen.getByPlaceholderText('Type a message...');
    await userEvent.type(input, 'Hello');
    await userEvent.click(screen.getByRole('button', { name: /send/i }));

    expect(input).toHaveValue('');
  });

  it('should disable input when loading', () => {
    render(<ChatInput onSend={vi.fn()} isLoading />);

    expect(screen.getByPlaceholderText('Type a message...')).toBeDisabled();
    expect(screen.getByRole('button', { name: /send/i })).toBeDisabled();
  });
});
```

### Hook 测试

```typescript
// useChat.test.ts
import { describe, it, expect, vi } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';
import { useChat } from './useChat';

describe('useChat', () => {
  it('should initialize with empty messages', () => {
    const { result } = renderHook(() => useChat());

    expect(result.current.messages).toEqual([]);
    expect(result.current.isLoading).toBe(false);
  });

  it('should add user message when sending', async () => {
    const { result } = renderHook(() => useChat());

    await act(async () => {
      await result.current.sendMessage('Hello');
    });

    expect(result.current.messages).toContainEqual(
      expect.objectContaining({
        role: 'user',
        content: 'Hello',
      })
    );
  });

  it('should set loading state while sending', async () => {
    const { result } = renderHook(() => useChat());

    act(() => {
      result.current.sendMessage('Hello');
    });

    expect(result.current.isLoading).toBe(true);

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });
  });

  it('should handle errors', async () => {
    // Mock API error
    vi.spyOn(global, 'fetch').mockRejectedValue(new Error('API Error'));

    const { result } = renderHook(() => useChat());

    await act(async () => {
      await result.current.sendMessage('Hello');
    });

    expect(result.current.error).toBe('API Error');
  });
});
```

### Store 测试

```typescript
// chatStore.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { useChatStore } from './chatStore';

describe('chatStore', () => {
  beforeEach(() => {
    // 重置 store 状态
    useChatStore.setState({
      conversations: [],
      activeConversationId: null,
      messages: {},
    });
  });

  it('should create conversation', () => {
    const { createConversation } = useChatStore.getState();

    createConversation({ title: 'Test' });

    const { conversations } = useChatStore.getState();
    expect(conversations).toHaveLength(1);
    expect(conversations[0].title).toBe('Test');
  });

  it('should set active conversation', () => {
    const { createConversation, setActiveConversation } =
      useChatStore.getState();

    createConversation({ title: 'Test' });
    const { conversations } = useChatStore.getState();

    setActiveConversation(conversations[0].id);

    expect(useChatStore.getState().activeConversationId).toBe(
      conversations[0].id
    );
  });

  it('should add message to conversation', () => {
    const { createConversation, addMessage } = useChatStore.getState();

    createConversation({ title: 'Test' });
    const { conversations } = useChatStore.getState();
    const conversationId = conversations[0].id;

    addMessage(conversationId, {
      role: 'user',
      content: 'Hello',
    });

    const { messages } = useChatStore.getState();
    expect(messages[conversationId]).toHaveLength(1);
    expect(messages[conversationId][0].content).toBe('Hello');
  });
});
```

---

## 集成测试

### API 集成测试

```typescript
// api.integration.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createServer } from '../server';
import { createTRPCClient } from '@trpc/client';

describe('API Integration', () => {
  let server: ReturnType<typeof createServer>;
  let client: ReturnType<typeof createTRPCClient>;

  beforeAll(async () => {
    server = createServer({ port: 0 }); // 随机端口
    await server.start();
    client = createTRPCClient({
      url: `http://localhost:${server.port}/api/trpc`,
    });
  });

  afterAll(async () => {
    await server.stop();
  });

  describe('conversation', () => {
    it('should create and retrieve conversation', async () => {
      // 创建会话
      const created = await client.conversation.create.mutate({
        title: 'Test Conversation',
      });

      expect(created.id).toBeDefined();
      expect(created.title).toBe('Test Conversation');

      // 获取会话列表
      const list = await client.conversation.list.query({});

      expect(list.items).toContainEqual(
        expect.objectContaining({ id: created.id })
      );
    });

    it('should update conversation', async () => {
      const created = await client.conversation.create.mutate({
        title: 'Original',
      });

      const updated = await client.conversation.update.mutate({
        id: created.id,
        title: 'Updated',
      });

      expect(updated.title).toBe('Updated');
    });

    it('should delete conversation', async () => {
      const created = await client.conversation.create.mutate({
        title: 'To Delete',
      });

      await client.conversation.delete.mutate({ id: created.id });

      const list = await client.conversation.list.query({});
      expect(list.items).not.toContainEqual(
        expect.objectContaining({ id: created.id })
      );
    });
  });
});
```

### 数据库集成测试

```typescript
// database.integration.test.ts
import { describe, it, expect, beforeEach, afterAll } from 'vitest';
import { db, schema } from '../database';
import { eq } from 'drizzle-orm';

describe('Database Integration', () => {
  beforeEach(async () => {
    // 清理测试数据
    await db.delete(schema.messages);
    await db.delete(schema.conversations);
  });

  afterAll(async () => {
    await db.$client.end();
  });

  it('should insert and query conversation', async () => {
    const [inserted] = await db
      .insert(schema.conversations)
      .values({
        title: 'Test',
        userId: 'test-user',
      })
      .returning();

    const [found] = await db
      .select()
      .from(schema.conversations)
      .where(eq(schema.conversations.id, inserted.id));

    expect(found.title).toBe('Test');
  });

  it('should cascade delete messages when conversation deleted', async () => {
    // 创建会话
    const [conversation] = await db
      .insert(schema.conversations)
      .values({ title: 'Test', userId: 'test-user' })
      .returning();

    // 创建消息
    await db.insert(schema.messages).values({
      conversationId: conversation.id,
      role: 'user',
      content: 'Hello',
    });

    // 删除会话
    await db
      .delete(schema.conversations)
      .where(eq(schema.conversations.id, conversation.id));

    // 验证消息也被删除
    const messages = await db
      .select()
      .from(schema.messages)
      .where(eq(schema.messages.conversationId, conversation.id));

    expect(messages).toHaveLength(0);
  });
});
```

---

## E2E 测试

### Playwright 配置

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  webServer: {
    command: 'pnpm dev:web',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
```

### E2E 测试用例

```typescript
// e2e/chat.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Chat', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should create new conversation', async ({ page }) => {
    // 点击新建会话按钮
    await page.click('[data-testid="new-conversation"]');

    // 验证新会话创建
    await expect(page.locator('[data-testid="conversation-item"]')).toHaveCount(
      1
    );
  });

  test('should send message and receive response', async ({ page }) => {
    // 创建新会话
    await page.click('[data-testid="new-conversation"]');

    // 输入消息
    const input = page.locator('[data-testid="chat-input"]');
    await input.fill('Hello, how are you?');

    // 发送消息
    await page.click('[data-testid="send-button"]');

    // 验证用户消息显示
    await expect(page.locator('[data-testid="user-message"]')).toContainText(
      'Hello, how are you?'
    );

    // 等待 AI 响应
    await expect(page.locator('[data-testid="assistant-message"]')).toBeVisible(
      { timeout: 30000 }
    );
  });

  test('should regenerate message', async ({ page }) => {
    // 创建会话并发送消息
    await page.click('[data-testid="new-conversation"]');
    await page.locator('[data-testid="chat-input"]').fill('Test message');
    await page.click('[data-testid="send-button"]');

    // 等待响应
    await expect(
      page.locator('[data-testid="assistant-message"]')
    ).toBeVisible();

    // 点击重新生成
    await page.click('[data-testid="regenerate-button"]');

    // 验证正在生成
    await expect(page.locator('[data-testid="loading-indicator"]')).toBeVisible();
  });

  test('should switch between conversations', async ({ page }) => {
    // 创建两个会话
    await page.click('[data-testid="new-conversation"]');
    await page.locator('[data-testid="chat-input"]').fill('First conversation');
    await page.click('[data-testid="send-button"]');

    await page.click('[data-testid="new-conversation"]');
    await page.locator('[data-testid="chat-input"]').fill('Second conversation');
    await page.click('[data-testid="send-button"]');

    // 切换到第一个会话
    await page.click('[data-testid="conversation-item"]:first-child');

    // 验证显示第一个会话的消息
    await expect(page.locator('[data-testid="user-message"]')).toContainText(
      'First conversation'
    );
  });
});
```

### 视觉回归测试

```typescript
// e2e/visual.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Visual Regression', () => {
  test('chat page should match snapshot', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    await expect(page).toHaveScreenshot('chat-page.png', {
      maxDiffPixels: 100,
    });
  });

  test('settings page should match snapshot', async ({ page }) => {
    await page.goto('/settings');
    await page.waitForLoadState('networkidle');

    await expect(page).toHaveScreenshot('settings-page.png', {
      maxDiffPixels: 100,
    });
  });

  test('dark mode should match snapshot', async ({ page }) => {
    await page.goto('/');
    await page.click('[data-testid="theme-toggle"]');
    await page.waitForTimeout(500); // 等待主题切换动画

    await expect(page).toHaveScreenshot('chat-page-dark.png', {
      maxDiffPixels: 100,
    });
  });
});
```

---

## Mock 服务

### MSW 配置

```typescript
// mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
  // 模拟聊天 API
  http.post('/api/chat', async ({ request }) => {
    const body = await request.json();

    return HttpResponse.json({
      id: 'msg-1',
      role: 'assistant',
      content: `Echo: ${body.message}`,
    });
  }),

  // 模拟流式响应
  http.post('/api/chat/stream', () => {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        const chunks = ['Hello', ' ', 'World', '!'];
        chunks.forEach((chunk, i) => {
          setTimeout(() => {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({ content: chunk })}\n\n`)
            );
            if (i === chunks.length - 1) {
              controller.enqueue(encoder.encode('data: [DONE]\n\n'));
              controller.close();
            }
          }, i * 100);
        });
      },
    });

    return new HttpResponse(stream, {
      headers: { 'Content-Type': 'text/event-stream' },
    });
  }),

  // 模拟知识库搜索
  http.post('/api/knowledge/search', async ({ request }) => {
    const body = await request.json();

    return HttpResponse.json({
      results: [
        {
          content: `Relevant content for: ${body.query}`,
          score: 0.95,
          documentId: 'doc-1',
        },
      ],
    });
  }),
];
```

### 测试中使用 MSW

```typescript
// setup.ts
import { setupServer } from 'msw/node';
import { handlers } from './mocks/handlers';

export const server = setupServer(...handlers);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

---

## 测试覆盖率

### 配置

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.d.ts',
        '**/*.test.ts',
        '**/*.spec.ts',
        '**/mocks/**',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 80,
        statements: 80,
      },
    },
  },
});
```

### 覆盖率要求

| 指标 | 最低要求 | 目标 |
|------|----------|------|
| 行覆盖率 | 80% | 90% |
| 函数覆盖率 | 80% | 90% |
| 分支覆盖率 | 80% | 85% |
| 语句覆盖率 | 80% | 90% |

---

## CI 集成

### GitHub Actions

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  unit-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v2
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - run: pnpm install
      - run: pnpm test:unit
      - run: pnpm test:coverage

      - uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json

  e2e-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v2
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - run: pnpm install
      - run: pnpm exec playwright install --with-deps
      - run: pnpm test:e2e

      - uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/
```

---

## 测试最佳实践

### 命名规范

```typescript
// 使用描述性的测试名称
describe('ChatService', () => {
  describe('sendMessage', () => {
    it('should return response when API call succeeds', () => {});
    it('should throw error when API returns 500', () => {});
    it('should retry on network timeout', () => {});
  });
});
```

### AAA 模式

```typescript
it('should add item to cart', () => {
  // Arrange - 准备
  const cart = new Cart();
  const item = { id: '1', name: 'Product', price: 100 };

  // Act - 执行
  cart.addItem(item);

  // Assert - 断言
  expect(cart.items).toContain(item);
  expect(cart.total).toBe(100);
});
```

### 避免测试实现细节

```typescript
// 不好的做法 - 测试实现细节
it('should set isLoading to true', () => {
  component.handleClick();
  expect(component.state.isLoading).toBe(true);
});

// 好的做法 - 测试行为
it('should show loading indicator when clicked', async () => {
  await userEvent.click(screen.getByRole('button'));
  expect(screen.getByTestId('loading')).toBeVisible();
});
```

### 测试隔离

```typescript
// 每个测试应该独立运行
beforeEach(() => {
  // 重置状态
  vi.clearAllMocks();
  localStorage.clear();
});
```
