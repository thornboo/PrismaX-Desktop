# 部署指南

> 本文档描述 PrismaX 的部署方案与流程

---

## 概述

PrismaX 支持多种部署方式：

| 部署方式 | 适用场景 | 复杂度 |
|----------|----------|--------|
| Docker Compose | 个人/小团队自托管 | 低 |
| Kubernetes | 企业级生产环境 | 高 |
| Vercel + 云服务 | 快速部署 | 低 |
| 桌面应用分发 | 终端用户 | 中 |

---

## Docker 部署

### 单机部署（Docker Compose）

#### 目录结构

```
deploy/
├── docker-compose.yml
├── docker-compose.prod.yml
├── .env.example
├── nginx/
│   └── nginx.conf
└── scripts/
    ├── backup.sh
    └── restore.sh
```

#### docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@db:5432/prismax
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    restart: unless-stopped
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:3000/api/health']
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: pgvector/pgvector:pg16
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=prismax
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres']
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

#### Dockerfile

```dockerfile
# 构建阶段
FROM node:20-alpine AS builder

WORKDIR /app

# 安装 pnpm
RUN corepack enable && corepack prepare pnpm@latest --activate

# 复制依赖文件
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY packages/*/package.json ./packages/
COPY apps/*/package.json ./apps/

# 安装依赖
RUN pnpm install --frozen-lockfile

# 复制源代码
COPY . .

# 构建
RUN pnpm build:web

# 生产阶段
FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production

# 创建非 root 用户
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# 复制构建产物
COPY --from=builder /app/apps/web/.next/standalone ./
COPY --from=builder /app/apps/web/.next/static ./apps/web/.next/static
COPY --from=builder /app/apps/web/public ./apps/web/public

USER nextjs

EXPOSE 3000

ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "apps/web/server.js"]
```

#### Nginx 配置

```nginx
# nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:3000;
    }

    # HTTP -> HTTPS 重定向
    server {
        listen 80;
        server_name _;
        return 301 https://$host$request_uri;
    }

    # HTTPS 服务器
    server {
        listen 443 ssl http2;
        server_name _;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
        ssl_prefer_server_ciphers off;

        # 安全头
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        add_header X-Content-Type-Options nosniff;
        add_header X-Frame-Options DENY;
        add_header X-XSS-Protection "1; mode=block";

        # Gzip 压缩
        gzip on;
        gzip_types text/plain text/css application/json application/javascript;

        location / {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # 静态文件缓存
        location /_next/static {
            proxy_pass http://app;
            proxy_cache_valid 200 365d;
            add_header Cache-Control "public, max-age=31536000, immutable";
        }
    }
}
```

#### 部署步骤

```bash
# 1. 克隆项目
git clone https://github.com/your-username/PrismaX.git
cd PrismaX

# 2. 配置环境变量
cp deploy/.env.example deploy/.env
# 编辑 .env 文件，设置必要的环境变量

# 3. 生成 SSL 证书（生产环境使用 Let's Encrypt）
# 开发环境可以使用自签名证书
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout deploy/nginx/ssl/key.pem \
  -out deploy/nginx/ssl/cert.pem

# 4. 启动服务
cd deploy
docker-compose up -d

# 5. 初始化数据库
docker-compose exec app pnpm db:migrate

# 6. 查看日志
docker-compose logs -f app
```

---

## Kubernetes 部署

### 架构图

```
                    +------------------+
                    |   Ingress        |
                    |   (nginx/traefik)|
                    +--------+---------+
                             |
              +--------------+--------------+
              |                             |
    +---------v---------+         +---------v---------+
    |   Service         |         |   Service         |
    |   (ClusterIP)     |         |   (ClusterIP)     |
    +---------+---------+         +---------+---------+
              |                             |
    +---------v---------+         +---------v---------+
    |   Deployment      |         |   StatefulSet     |
    |   (App Pods)      |         |   (PostgreSQL)    |
    +-------------------+         +-------------------+
```

### Kubernetes 配置

#### namespace.yaml

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: prismax
```

#### configmap.yaml

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prismax-config
  namespace: prismax
data:
  NODE_ENV: 'production'
  NEXT_PUBLIC_APP_URL: 'https://app.prismax.com'
```

#### secret.yaml

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: prismax-secrets
  namespace: prismax
type: Opaque
stringData:
  DATABASE_URL: 'postgresql://user:password@postgres:5432/prismax'
  REDIS_URL: 'redis://redis:6379'
  JWT_SECRET: 'your-jwt-secret'
  ENCRYPTION_KEY: 'your-encryption-key'
```

#### deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prismax-app
  namespace: prismax
spec:
  replicas: 3
  selector:
    matchLabels:
      app: prismax
  template:
    metadata:
      labels:
        app: prismax
    spec:
      containers:
        - name: app
          image: prismax/app:latest
          ports:
            - containerPort: 3000
          envFrom:
            - configMapRef:
                name: prismax-config
            - secretRef:
                name: prismax-secrets
          resources:
            requests:
              memory: '256Mi'
              cpu: '250m'
            limits:
              memory: '512Mi'
              cpu: '500m'
          livenessProbe:
            httpGet:
              path: /api/health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /api/health
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
      imagePullSecrets:
        - name: registry-credentials
```

#### service.yaml

```yaml
apiVersion: v1
kind: Service
metadata:
  name: prismax-service
  namespace: prismax
spec:
  selector:
    app: prismax
  ports:
    - port: 80
      targetPort: 3000
  type: ClusterIP
```

#### ingress.yaml

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: prismax-ingress
  namespace: prismax
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: 'true'
spec:
  tls:
    - hosts:
        - app.prismax.com
      secretName: prismax-tls
  rules:
    - host: app.prismax.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: prismax-service
                port:
                  number: 80
```

#### hpa.yaml（自动扩缩容）

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: prismax-hpa
  namespace: prismax
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: prismax-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
```

### 部署命令

```bash
# 应用所有配置
kubectl apply -f k8s/

# 查看部署状态
kubectl get pods -n prismax

# 查看日志
kubectl logs -f deployment/prismax-app -n prismax

# 扩容
kubectl scale deployment prismax-app --replicas=5 -n prismax
```

---

## Vercel 部署

### 配置文件

```json
// vercel.json
{
  "buildCommand": "pnpm build:web",
  "outputDirectory": "apps/web/.next",
  "framework": "nextjs",
  "regions": ["hnd1", "sfo1"],
  "env": {
    "NEXT_PUBLIC_APP_URL": "@app_url"
  }
}
```

### 部署步骤

```bash
# 1. 安装 Vercel CLI
npm i -g vercel

# 2. 登录
vercel login

# 3. 部署
vercel --prod

# 4. 配置环境变量（在 Vercel 控制台）
# DATABASE_URL, REDIS_URL, JWT_SECRET 等
```

### 外部服务配置

| 服务 | 推荐方案 |
|------|----------|
| PostgreSQL | Supabase / Neon / PlanetScale |
| Redis | Upstash / Redis Cloud |
| 文件存储 | Vercel Blob / AWS S3 |
| 向量数据库 | Pinecone / Supabase pgvector |

---

## 桌面应用分发

### 构建配置

```typescript
// electron-builder.config.ts
import { Configuration } from 'electron-builder';

const config: Configuration = {
  appId: 'com.prismax.app',
  productName: 'PrismaX',
  directories: {
    output: 'release',
  },
  files: ['dist/**/*', 'package.json'],
  mac: {
    category: 'public.app-category.productivity',
    target: [
      { target: 'dmg', arch: ['x64', 'arm64'] },
      { target: 'zip', arch: ['x64', 'arm64'] },
    ],
    hardenedRuntime: true,
    gatekeeperAssess: false,
    entitlements: 'build/entitlements.mac.plist',
    entitlementsInherit: 'build/entitlements.mac.plist',
  },
  win: {
    target: [
      { target: 'nsis', arch: ['x64'] },
      { target: 'portable', arch: ['x64'] },
    ],
    certificateFile: process.env.WIN_CERT_FILE,
    certificatePassword: process.env.WIN_CERT_PASSWORD,
  },
  linux: {
    target: [
      { target: 'AppImage', arch: ['x64'] },
      { target: 'deb', arch: ['x64'] },
      { target: 'rpm', arch: ['x64'] },
    ],
    category: 'Utility',
  },
  nsis: {
    oneClick: false,
    allowToChangeInstallationDirectory: true,
    createDesktopShortcut: true,
    createStartMenuShortcut: true,
  },
  publish: {
    provider: 'github',
    owner: 'your-username',
    repo: 'PrismaX',
    releaseType: 'release',
  },
};

export default config;
```

### 自动更新

```typescript
// desktop/updater.ts
import { autoUpdater } from 'electron-updater';
import { app, dialog } from 'electron';

export function initAutoUpdater() {
  autoUpdater.autoDownload = false;
  autoUpdater.autoInstallOnAppQuit = true;

  autoUpdater.on('update-available', (info) => {
    dialog
      .showMessageBox({
        type: 'info',
        title: '发现新版本',
        message: `新版本 ${info.version} 可用，是否下载？`,
        buttons: ['下载', '稍后'],
      })
      .then((result) => {
        if (result.response === 0) {
          autoUpdater.downloadUpdate();
        }
      });
  });

  autoUpdater.on('update-downloaded', () => {
    dialog
      .showMessageBox({
        type: 'info',
        title: '更新已下载',
        message: '更新已下载完成，重启应用以安装更新',
        buttons: ['立即重启', '稍后'],
      })
      .then((result) => {
        if (result.response === 0) {
          autoUpdater.quitAndInstall();
        }
      });
  });

  // 检查更新
  autoUpdater.checkForUpdates();
}
```

### 构建与发布

```bash
# 构建所有平台
pnpm build:desktop

# 仅构建 macOS
pnpm build:desktop --mac

# 仅构建 Windows
pnpm build:desktop --win

# 仅构建 Linux
pnpm build:desktop --linux

# 发布到 GitHub Releases
pnpm release:desktop
```

---

## CI/CD 流水线

### GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]
  release:
    types: [published]

jobs:
  # Web 部署
  deploy-web:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Build
        run: pnpm build:web
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'

  # Docker 镜像构建
  build-docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # 桌面应用构建
  build-desktop:
    if: github.event_name == 'release'
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Build Desktop App
        run: pnpm build:desktop
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CSC_LINK: ${{ secrets.MAC_CERT_P12 }}
          CSC_KEY_PASSWORD: ${{ secrets.MAC_CERT_PASSWORD }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: desktop-${{ matrix.os }}
          path: release/*
```

---

## 环境变量

### 必需变量

| 变量名 | 说明 | 示例 |
|--------|------|------|
| `DATABASE_URL` | PostgreSQL 连接字符串 | `postgresql://user:pass@host:5432/db` |
| `REDIS_URL` | Redis 连接字符串 | `redis://host:6379` |
| `JWT_SECRET` | JWT 签名密钥 | 随机 32 字节字符串 |
| `ENCRYPTION_KEY` | 数据加密密钥 | 随机 32 字节字符串 |

### 可选变量

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| `PORT` | 服务端口 | `3000` |
| `NODE_ENV` | 运行环境 | `development` |
| `LOG_LEVEL` | 日志级别 | `info` |
| `CORS_ORIGINS` | CORS 允许的源 | `*` |

### 生成密钥

```bash
# 生成随机密钥
openssl rand -hex 32

# 或使用 Node.js
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

---

## 监控与告警

### 健康检查端点

```typescript
// pages/api/health.ts
export default function handler(req, res) {
  const health = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
  };

  res.status(200).json(health);
}
```

### Prometheus 指标

```typescript
// metrics.ts
import { Registry, Counter, Histogram } from 'prom-client';

const register = new Registry();

export const httpRequestsTotal = new Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'path', 'status'],
  registers: [register],
});

export const httpRequestDuration = new Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration in seconds',
  labelNames: ['method', 'path'],
  buckets: [0.1, 0.5, 1, 2, 5],
  registers: [register],
});
```

### 告警规则

```yaml
# prometheus/alerts.yml
groups:
  - name: prismax
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: High error rate detected

      - alert: HighLatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: High latency detected
```

---

## 备份与恢复

### 数据库备份

```bash
#!/bin/bash
# scripts/backup.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR=/backups

# PostgreSQL 备份
docker-compose exec -T db pg_dump -U postgres prismax | gzip > $BACKUP_DIR/db_$DATE.sql.gz

# 保留最近 7 天的备份
find $BACKUP_DIR -name "db_*.sql.gz" -mtime +7 -delete

# 上传到 S3（可选）
aws s3 cp $BACKUP_DIR/db_$DATE.sql.gz s3://your-bucket/backups/
```

### 数据库恢复

```bash
#!/bin/bash
# scripts/restore.sh

BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
  echo "Usage: ./restore.sh <backup_file>"
  exit 1
fi

# 恢复数据库
gunzip -c $BACKUP_FILE | docker-compose exec -T db psql -U postgres prismax
```

### 定时备份（Cron）

```bash
# 每天凌晨 2 点备份
0 2 * * * /path/to/scripts/backup.sh >> /var/log/backup.log 2>&1
```

---

## 故障排查

### 常见问题

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| 数据库连接失败 | 网络/凭证问题 | 检查 DATABASE_URL 和网络连通性 |
| 内存溢出 | 内存限制过低 | 增加容器内存限制 |
| 响应超时 | AI API 延迟 | 增加超时时间，添加重试机制 |
| SSL 证书错误 | 证书过期/配置错误 | 更新证书，检查 Nginx 配置 |

### 日志查看

```bash
# Docker Compose
docker-compose logs -f app

# Kubernetes
kubectl logs -f deployment/prismax-app -n prismax

# 查看特定时间段
kubectl logs --since=1h deployment/prismax-app -n prismax
```

### 性能分析

```bash
# 查看容器资源使用
docker stats

# Kubernetes 资源使用
kubectl top pods -n prismax
```
