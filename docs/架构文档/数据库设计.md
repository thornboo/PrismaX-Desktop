# 数据库设计

> 本文档描述 PrismaX-Desktop 桌面应用的数据库设计

> 注意：本文档包含早期规划内容，可能与当前实现存在差异。当前实现以 `electron/db/schema.ts` 与 `electron/db/index.ts` 为准；知识库/索引/任务/插件边界的规划见 [本地数据平台.md](./本地数据平台.md)。

---

## 数据库选型

| 类别           | 选型       | 说明                                   |
| -------------- | ---------- | -------------------------------------- |
| **本地数据库** | SQLite     | better-sqlite3，高性能本地存储         |
| **ORM**        | Drizzle    | 类型安全、轻量、高性能                 |
| **向量存储**   | 可插拔引擎 | 语义检索索引（规划中，以可替换为原则） |

---

## 数据库架构

```
┌─────────────────────────────────────────────────────────────┐
│                    PrismaX-Desktop 数据存储                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    SQLite 数据库                      │   │
│  │                                                     │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐       │   │
│  │  │ 会话表    │  │ 消息表    │  │ 设置表    │       │   │
│  │  │conversations│ │ messages  │  │ settings  │       │   │
│  │  └───────────┘  └───────────┘  └───────────┘       │   │
│  │                                                     │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐       │   │
│  │  │ 助手表    │  │ 文件夹表  │  │ 模型配置  │       │   │
│  │  │ assistants│  │ folders   │  │ providers │       │   │
│  │  └───────────┘  └───────────┘  └───────────┘       │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    文件存储                          │   │
│  │  • 数据库文件: ~/Library/Application Support/PrismaX-Desktop │   │
│  │  • 日志文件: ~/Library/Logs/PrismaX-Desktop                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 当前落地：知识库独立 Meta DB

除主库 `prismax.db` 外，知识库采用 **每库一个目录 + 独立 `meta.sqlite`** 的结构（详见 [本地数据平台.md](./本地数据平台.md)）：

- `meta.sqlite` 内置 `schema_migrations` 做增量迁移（避免 `CREATE TABLE IF NOT EXISTS` schema 漂移）。
- `chunks` + `FTS5(chunks_fts)` 作为全文检索主力。
- `blobs(sha256, ref_count)` + `file_fingerprints(source_path,size,mtime->sha256)` 支撑 100GB 级别导入去重与增量处理。
- 向量索引（派生数据）：
  - `vector_config(provider_id, model, dimension)` 记录当前向量索引配置
  - `chunk_vectors(chunk_id, config_hash)` 用于增量/断点续跑
  - 索引文件存放于 `<kbDir>/index/vector/lancedb/`（LanceDB）

---

## 数据库 Schema

### 会话表

```sql
-- 会话表
CREATE TABLE conversations (
  id TEXT PRIMARY KEY,
  title TEXT,
  model TEXT,
  system_prompt TEXT,
  folder_id TEXT REFERENCES folders(id) ON DELETE SET NULL,
  is_pinned INTEGER DEFAULT 0,
  is_archived INTEGER DEFAULT 0,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);

-- 索引
CREATE INDEX idx_conversations_folder_id ON conversations(folder_id);
CREATE INDEX idx_conversations_updated_at ON conversations(updated_at);
```

### 消息表

```sql
-- 消息表
CREATE TABLE messages (
  id TEXT PRIMARY KEY,
  conversation_id TEXT NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  role TEXT NOT NULL,  -- 'user' | 'assistant' | 'system'
  content TEXT NOT NULL,
  model TEXT,
  tokens_used INTEGER,
  metadata TEXT DEFAULT '{}',
  parent_id TEXT,  -- 用于分支对话
  created_at TEXT DEFAULT (datetime('now'))
);

-- 索引
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

### 文件夹表

```sql
-- 文件夹表
CREATE TABLE folders (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  parent_id TEXT REFERENCES folders(id) ON DELETE CASCADE,
  sort_order INTEGER DEFAULT 0,
  created_at TEXT DEFAULT (datetime('now'))
);

-- 索引
CREATE INDEX idx_folders_parent_id ON folders(parent_id);
```

### 助手表

```sql
-- 助手表
CREATE TABLE assistants (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  avatar TEXT,
  model TEXT,
  system_prompt TEXT,
  temperature REAL DEFAULT 0.7,
  max_tokens INTEGER,
  knowledge_base_ids TEXT DEFAULT '[]',  -- JSON 数组
  tools TEXT DEFAULT '[]',  -- JSON 数组
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);
```

### 模型配置表

```sql
-- 模型提供商配置表
CREATE TABLE model_providers (
  id TEXT PRIMARY KEY,
  provider TEXT NOT NULL UNIQUE,  -- 'openai' | 'anthropic' | 'ollama' | ...
  name TEXT,
  api_key TEXT,  -- 加密存储
  base_url TEXT,
  is_enabled INTEGER DEFAULT 1,
  config TEXT DEFAULT '{}',  -- JSON 配置
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);
```

### 设置表

```sql
-- 设置表
CREATE TABLE settings (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at TEXT DEFAULT (datetime('now'))
);
```

---

## Drizzle ORM Schema

### Schema 定义

```typescript
// electron/db/schema.ts
import { sqliteTable, text, integer, real } from "drizzle-orm/sqlite-core";

// 会话表
export const conversations = sqliteTable("conversations", {
  id: text("id").primaryKey(),
  title: text("title"),
  model: text("model"),
  systemPrompt: text("system_prompt"),
  folderId: text("folder_id").references(() => folders.id, { onDelete: "set null" }),
  isPinned: integer("is_pinned", { mode: "boolean" }).default(false),
  isArchived: integer("is_archived", { mode: "boolean" }).default(false),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

// 消息表
export const messages = sqliteTable("messages", {
  id: text("id").primaryKey(),
  conversationId: text("conversation_id")
    .notNull()
    .references(() => conversations.id, { onDelete: "cascade" }),
  role: text("role").notNull(),
  content: text("content").notNull(),
  model: text("model"),
  tokensUsed: integer("tokens_used"),
  metadata: text("metadata").default("{}"),
  parentId: text("parent_id"),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

// 文件夹表
export const folders = sqliteTable("folders", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  parentId: text("parent_id").references(() => folders.id, { onDelete: "cascade" }),
  sortOrder: integer("sort_order").default(0),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
});

// 助手表
export const assistants = sqliteTable("assistants", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  avatar: text("avatar"),
  model: text("model"),
  systemPrompt: text("system_prompt"),
  temperature: real("temperature").default(0.7),
  maxTokens: integer("max_tokens"),
  knowledgeBaseIds: text("knowledge_base_ids").default("[]"),
  tools: text("tools").default("[]"),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

// 模型提供商配置表
export const modelProviders = sqliteTable("model_providers", {
  id: text("id").primaryKey(),
  provider: text("provider").notNull().unique(),
  name: text("name"),
  apiKey: text("api_key"),
  baseUrl: text("base_url"),
  isEnabled: integer("is_enabled", { mode: "boolean" }).default(true),
  config: text("config").default("{}"),
  createdAt: text("created_at").default(sql`(datetime('now'))`),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});

// 设置表
export const settings = sqliteTable("settings", {
  key: text("key").primaryKey(),
  value: text("value").notNull(),
  updatedAt: text("updated_at").default(sql`(datetime('now'))`),
});
```

---

## 数据库初始化

```typescript
// electron/db/index.ts
import Database from "better-sqlite3";
import { drizzle } from "drizzle-orm/better-sqlite3";
import { app } from "electron";
import path from "path";
import * as schema from "./schema";

let db: ReturnType<typeof drizzle> | null = null;

export function getDatabase() {
  if (db) return db;

  // 数据库文件路径
  const dbPath = path.join(app.getPath("userData"), "prismax.db");

  // 创建 SQLite 连接
  const sqlite = new Database(dbPath);

  // 启用 WAL 模式（提高并发性能）
  sqlite.pragma("journal_mode = WAL");

  // 创建 Drizzle 实例
  db = drizzle(sqlite, { schema });

  // 运行迁移
  runMigrations(sqlite);

  return db;
}

function runMigrations(sqlite: Database.Database) {
  const currentVersion = sqlite.pragma("user_version", { simple: true }) as number;

  const migrations = [
    {
      version: 1,
      up: `
        CREATE TABLE IF NOT EXISTS conversations (
          id TEXT PRIMARY KEY,
          title TEXT,
          model TEXT,
          system_prompt TEXT,
          folder_id TEXT,
          is_pinned INTEGER DEFAULT 0,
          is_archived INTEGER DEFAULT 0,
          created_at TEXT DEFAULT (datetime('now')),
          updated_at TEXT DEFAULT (datetime('now'))
        );

        CREATE TABLE IF NOT EXISTS messages (
          id TEXT PRIMARY KEY,
          conversation_id TEXT NOT NULL,
          role TEXT NOT NULL,
          content TEXT NOT NULL,
          model TEXT,
          tokens_used INTEGER,
          metadata TEXT DEFAULT '{}',
          parent_id TEXT,
          created_at TEXT DEFAULT (datetime('now')),
          FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS folders (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          parent_id TEXT,
          sort_order INTEGER DEFAULT 0,
          created_at TEXT DEFAULT (datetime('now')),
          FOREIGN KEY (parent_id) REFERENCES folders(id) ON DELETE CASCADE
        );

        CREATE TABLE IF NOT EXISTS settings (
          key TEXT PRIMARY KEY,
          value TEXT NOT NULL,
          updated_at TEXT DEFAULT (datetime('now'))
        );

        CREATE INDEX IF NOT EXISTS idx_conversations_folder_id ON conversations(folder_id);
        CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages(conversation_id);
        CREATE INDEX IF NOT EXISTS idx_folders_parent_id ON folders(parent_id);
      `,
    },
    {
      version: 2,
      up: `
        CREATE TABLE IF NOT EXISTS assistants (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          description TEXT,
          avatar TEXT,
          model TEXT,
          system_prompt TEXT,
          temperature REAL DEFAULT 0.7,
          max_tokens INTEGER,
          knowledge_base_ids TEXT DEFAULT '[]',
          tools TEXT DEFAULT '[]',
          created_at TEXT DEFAULT (datetime('now')),
          updated_at TEXT DEFAULT (datetime('now'))
        );

        CREATE TABLE IF NOT EXISTS model_providers (
          id TEXT PRIMARY KEY,
          provider TEXT NOT NULL UNIQUE,
          name TEXT,
          api_key TEXT,
          base_url TEXT,
          is_enabled INTEGER DEFAULT 1,
          config TEXT DEFAULT '{}',
          created_at TEXT DEFAULT (datetime('now')),
          updated_at TEXT DEFAULT (datetime('now'))
        );
      `,
    },
  ];

  for (const migration of migrations) {
    if (migration.version > currentVersion) {
      sqlite.exec(migration.up);
      sqlite.pragma(`user_version = ${migration.version}`);
    }
  }
}
```

---

## 数据访问层

### Repository 模式

```typescript
// electron/db/repositories/conversation.ts
import { eq, desc } from "drizzle-orm";
import { getDatabase } from "../index";
import { conversations, messages } from "../schema";
import { generateId } from "../../utils/id";

export class ConversationRepository {
  private db = getDatabase();

  async findAll() {
    return this.db.select().from(conversations).orderBy(desc(conversations.updatedAt));
  }

  async findById(id: string) {
    const [result] = await this.db.select().from(conversations).where(eq(conversations.id, id));
    return result || null;
  }

  async create(data: { title?: string; model?: string }) {
    const id = generateId();
    const now = new Date().toISOString();

    await this.db.insert(conversations).values({
      id,
      title: data.title || "新对话",
      model: data.model,
      createdAt: now,
      updatedAt: now,
    });

    return this.findById(id);
  }

  async update(id: string, data: Partial<typeof conversations.$inferInsert>) {
    await this.db
      .update(conversations)
      .set({ ...data, updatedAt: new Date().toISOString() })
      .where(eq(conversations.id, id));

    return this.findById(id);
  }

  async delete(id: string) {
    await this.db.delete(conversations).where(eq(conversations.id, id));
  }

  async getMessages(conversationId: string) {
    return this.db
      .select()
      .from(messages)
      .where(eq(messages.conversationId, conversationId))
      .orderBy(messages.createdAt);
  }
}
```

### 消息 Repository

```typescript
// electron/db/repositories/message.ts
import { eq } from "drizzle-orm";
import { getDatabase } from "../index";
import { messages } from "../schema";
import { generateId } from "../../utils/id";

export class MessageRepository {
  private db = getDatabase();

  async create(data: {
    conversationId: string;
    role: "user" | "assistant" | "system";
    content: string;
    model?: string;
  }) {
    const id = generateId();

    await this.db.insert(messages).values({
      id,
      conversationId: data.conversationId,
      role: data.role,
      content: data.content,
      model: data.model,
      createdAt: new Date().toISOString(),
    });

    return this.findById(id);
  }

  async findById(id: string) {
    const [result] = await this.db.select().from(messages).where(eq(messages.id, id));
    return result || null;
  }

  async update(id: string, content: string) {
    await this.db.update(messages).set({ content }).where(eq(messages.id, id));

    return this.findById(id);
  }

  async delete(id: string) {
    await this.db.delete(messages).where(eq(messages.id, id));
  }

  async deleteByConversation(conversationId: string) {
    await this.db.delete(messages).where(eq(messages.conversationId, conversationId));
  }
}
```

---

## 数据存储位置

| 平台        | 数据库路径                                                 |
| ----------- | ---------------------------------------------------------- |
| **macOS**   | `~/Library/Application Support/PrismaX-Desktop/prismax.db` |
| **Windows** | `%APPDATA%/PrismaX-Desktop/prismax.db`                     |
| **Linux**   | `~/.config/PrismaX-Desktop/prismax.db`                     |

---

## 数据备份与恢复

```typescript
// electron/services/backup.ts
import { app } from "electron";
import fs from "fs";
import path from "path";

export class BackupService {
  private dbPath = path.join(app.getPath("userData"), "prismax.db");

  async createBackup(): Promise<string> {
    const backupDir = path.join(app.getPath("userData"), "backups");
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const backupPath = path.join(backupDir, `prismax-${timestamp}.db`);

    fs.copyFileSync(this.dbPath, backupPath);
    return backupPath;
  }

  async restoreBackup(backupPath: string): Promise<void> {
    if (!fs.existsSync(backupPath)) {
      throw new Error("备份文件不存在");
    }

    fs.copyFileSync(backupPath, this.dbPath);
  }

  async listBackups(): Promise<string[]> {
    const backupDir = path.join(app.getPath("userData"), "backups");
    if (!fs.existsSync(backupDir)) {
      return [];
    }

    return fs
      .readdirSync(backupDir)
      .filter((f) => f.endsWith(".db"))
      .sort()
      .reverse();
  }
}
```

---

## 性能优化

### WAL 模式

```typescript
// 启用 WAL 模式提高并发性能
sqlite.pragma("journal_mode = WAL");
```

### 索引优化

```sql
-- 常用查询索引
CREATE INDEX idx_conversations_updated_at ON conversations(updated_at);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

### 查询优化

```typescript
// 分页查询
async findConversations(page: number, pageSize: number = 20) {
  return this.db
    .select()
    .from(conversations)
    .orderBy(desc(conversations.updatedAt))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}

// 只查询需要的字段
async findConversationTitles() {
  return this.db
    .select({ id: conversations.id, title: conversations.title })
    .from(conversations)
    .orderBy(desc(conversations.updatedAt));
}
```
