# 跨平台适配设计

> 本文档描述 PrismaX 的 Web/Desktop 跨平台适配架构

---

## 概述

PrismaX 采用 **Web 优先** 策略：
1. v0.1.0 先实现 Web 版，验证核心架构
2. v0.2.0 Desktop 版复用 Web 渲染层，套 Electron 壳

为实现代码最大化复用，需要在关键模块设计抽象层。

---

## 架构策略

### Desktop 复用 Web 渲染层

```
┌─────────────────────────────────────────────────────────────┐
│                    apps/desktop (Electron)                  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                    主进程 (Main)                       │  │
│  │  - 窗口管理                                            │  │
│  │  - IPC 处理                                            │  │
│  │  - 系统集成（托盘、快捷键、自动更新）                    │  │
│  │  - 本地能力（文件系统、Keychain、SQLite）               │  │
│  └───────────────────────────────────────────────────────┘  │
│                            │ IPC                            │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                   渲染进程 (Renderer)                   │  │
│  │  ┌─────────────────────────────────────────────────┐  │  │
│  │  │              apps/web (Next.js)                 │  │  │
│  │  │  - 开发时：加载 http://localhost:3000           │  │  │
│  │  │  - 生产时：加载构建产物                          │  │  │
│  │  └─────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 平台检测

```typescript
// packages/shared/src/platform.ts
export type Platform = 'web' | 'desktop';

export function getPlatform(): Platform {
  if (typeof window !== 'undefined' && window.electronAPI) {
    return 'desktop';
  }
  return 'web';
}

export function isDesktop(): boolean {
  return getPlatform() === 'desktop';
}

export function isWeb(): boolean {
  return getPlatform() === 'web';
}
```

---

## 数据层抽象

### 数据库适配器接口

```typescript
// packages/database/src/adapter.ts
export interface DatabaseAdapter {
  // 会话
  conversations: ConversationRepository;
  // 消息
  messages: MessageRepository;
  // 设置
  settings: SettingsRepository;
  // API 密钥
  apiKeys: APIKeyRepository;
  // 知识库（后期）
  knowledgeBases?: KnowledgeBaseRepository;

  // 生命周期
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  migrate(): Promise<void>;
}

// 仓库接口示例
export interface ConversationRepository {
  findAll(userId?: string): Promise<Conversation[]>;
  findById(id: string): Promise<Conversation | null>;
  create(data: CreateConversationInput): Promise<Conversation>;
  update(id: string, data: UpdateConversationInput): Promise<Conversation>;
  delete(id: string): Promise<void>;
}

export interface MessageRepository {
  findByConversation(conversationId: string): Promise<Message[]>;
  create(data: CreateMessageInput): Promise<Message>;
  update(id: string, data: UpdateMessageInput): Promise<Message>;
  delete(id: string): Promise<void>;
  deleteByConversation(conversationId: string): Promise<void>;
}
```

### PostgreSQL 适配器（Web）

```typescript
// packages/database/src/adapters/postgres.ts
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';
import * as schema from '../schema';

export class PostgresAdapter implements DatabaseAdapter {
  private pool: Pool;
  private db: ReturnType<typeof drizzle>;

  constructor(connectionString: string) {
    this.pool = new Pool({ connectionString });
    this.db = drizzle(this.pool, { schema });
  }

  conversations = {
    findAll: async (userId?: string) => {
      let query = this.db.select().from(schema.conversations);
      if (userId) {
        query = query.where(eq(schema.conversations.userId, userId));
      }
      return query.orderBy(desc(schema.conversations.updatedAt));
    },

    findById: async (id: string) => {
      const [result] = await this.db
        .select()
        .from(schema.conversations)
        .where(eq(schema.conversations.id, id));
      return result || null;
    },

    create: async (data: CreateConversationInput) => {
      const [result] = await this.db
        .insert(schema.conversations)
        .values({
          id: generateId(),
          ...data,
          createdAt: new Date(),
          updatedAt: new Date(),
        })
        .returning();
      return result;
    },

    update: async (id: string, data: UpdateConversationInput) => {
      const [result] = await this.db
        .update(schema.conversations)
        .set({ ...data, updatedAt: new Date() })
        .where(eq(schema.conversations.id, id))
        .returning();
      return result;
    },

    delete: async (id: string) => {
      await this.db
        .delete(schema.conversations)
        .where(eq(schema.conversations.id, id));
    },
  };

  // ... 其他仓库实现

  async connect() {
    await this.pool.connect();
  }

  async disconnect() {
    await this.pool.end();
  }

  async migrate() {
    // 使用 drizzle-kit 迁移
  }
}
```

### SQLite 适配器（Desktop）

```typescript
// packages/database/src/adapters/sqlite.ts
import Database from 'better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import * as schema from '../schema/sqlite';

export class SQLiteAdapter implements DatabaseAdapter {
  private sqlite: Database.Database;
  private db: ReturnType<typeof drizzle>;

  constructor(dbPath: string) {
    this.sqlite = new Database(dbPath);
    this.db = drizzle(this.sqlite, { schema });
  }

  conversations = {
    findAll: async () => {
      return this.db
        .select()
        .from(schema.conversations)
        .orderBy(desc(schema.conversations.updatedAt))
        .all();
    },

    findById: async (id: string) => {
      const result = this.db
        .select()
        .from(schema.conversations)
        .where(eq(schema.conversations.id, id))
        .get();
      return result || null;
    },

    create: async (data: CreateConversationInput) => {
      const id = generateId();
      const now = new Date().toISOString();
      this.db.insert(schema.conversations).values({
        id,
        ...data,
        createdAt: now,
        updatedAt: now,
      }).run();
      return this.conversations.findById(id);
    },

    // ... 其他方法
  };

  async connect() {
    // SQLite 无需显式连接
  }

  async disconnect() {
    this.sqlite.close();
  }

  async migrate() {
    // 使用 drizzle-kit 迁移
  }
}
```

### 适配器工厂

```typescript
// packages/database/src/index.ts
import { getPlatform } from '@prismax/shared';

let adapter: DatabaseAdapter | null = null;

export async function getDatabase(): Promise<DatabaseAdapter> {
  if (adapter) return adapter;

  const platform = getPlatform();

  if (platform === 'desktop') {
    const { SQLiteAdapter } = await import('./adapters/sqlite');
    const dbPath = await window.electronAPI.getDbPath();
    adapter = new SQLiteAdapter(dbPath);
  } else {
    const { PostgresAdapter } = await import('./adapters/postgres');
    adapter = new PostgresAdapter(process.env.DATABASE_URL!);
  }

  await adapter.connect();
  await adapter.migrate();

  return adapter;
}

export { DatabaseAdapter } from './adapter';
```

---

## API Key 存储抽象

### KeyStore 接口

```typescript
// packages/core/src/security/key-store.ts
export interface KeyStore {
  get(provider: string): Promise<string | null>;
  set(provider: string, key: string): Promise<void>;
  delete(provider: string): Promise<void>;
  list(): Promise<string[]>;
}
```

### 数据库 KeyStore（Web）

```typescript
// packages/core/src/security/database-key-store.ts
import { getDatabase } from '@prismax/database';
import { encrypt, decrypt } from './crypto';

export class DatabaseKeyStore implements KeyStore {
  private encryptionKey: Buffer;

  constructor(encryptionKey: string) {
    this.encryptionKey = Buffer.from(encryptionKey, 'hex');
  }

  async get(provider: string): Promise<string | null> {
    const db = await getDatabase();
    const record = await db.apiKeys.findByProvider(provider);
    if (!record) return null;
    return decrypt(record.encryptedKey, this.encryptionKey);
  }

  async set(provider: string, key: string): Promise<void> {
    const db = await getDatabase();
    const encryptedKey = encrypt(key, this.encryptionKey);
    await db.apiKeys.upsert(provider, encryptedKey);
  }

  async delete(provider: string): Promise<void> {
    const db = await getDatabase();
    await db.apiKeys.delete(provider);
  }

  async list(): Promise<string[]> {
    const db = await getDatabase();
    const records = await db.apiKeys.findAll();
    return records.map((r) => r.provider);
  }
}
```

### Keychain KeyStore（Desktop）

```typescript
// packages/core/src/security/keychain-store.ts
// 此实现在 Electron 主进程中运行，通过 IPC 暴露给渲染进程

export class KeychainStore implements KeyStore {
  private serviceName = 'PrismaX';

  async get(provider: string): Promise<string | null> {
    // 通过 IPC 调用主进程
    return window.electronAPI.keychain.get(provider);
  }

  async set(provider: string, key: string): Promise<void> {
    return window.electronAPI.keychain.set(provider, key);
  }

  async delete(provider: string): Promise<void> {
    return window.electronAPI.keychain.delete(provider);
  }

  async list(): Promise<string[]> {
    return window.electronAPI.keychain.list();
  }
}

// Electron 主进程实现
// apps/desktop/electron/ipc/keychain.ts
import keytar from 'keytar';

const SERVICE_NAME = 'PrismaX';

export const keychainHandlers = {
  'keychain:get': async (provider: string) => {
    return keytar.getPassword(SERVICE_NAME, provider);
  },

  'keychain:set': async (provider: string, key: string) => {
    await keytar.setPassword(SERVICE_NAME, provider, key);
  },

  'keychain:delete': async (provider: string) => {
    await keytar.deletePassword(SERVICE_NAME, provider);
  },

  'keychain:list': async () => {
    const credentials = await keytar.findCredentials(SERVICE_NAME);
    return credentials.map((c) => c.account);
  },
};
```

### KeyStore 工厂

```typescript
// packages/core/src/security/index.ts
import { getPlatform } from '@prismax/shared';

let keyStore: KeyStore | null = null;

export async function getKeyStore(): Promise<KeyStore> {
  if (keyStore) return keyStore;

  const platform = getPlatform();

  if (platform === 'desktop') {
    const { KeychainStore } = await import('./keychain-store');
    keyStore = new KeychainStore();
  } else {
    const { DatabaseKeyStore } = await import('./database-key-store');
    keyStore = new DatabaseKeyStore(process.env.ENCRYPTION_KEY!);
  }

  return keyStore;
}
```

---

## Ollama 集成

### Web 端注意事项

Web 端调用本地 Ollama 需要处理 CORS：

```typescript
// packages/ai-sdk/src/providers/ollama/index.ts
export class OllamaProvider implements AIProvider {
  private baseUrl: string;
  private useProxy: boolean;

  constructor(config: OllamaConfig) {
    this.baseUrl = config.baseUrl || 'http://localhost:11434';
    // Web 端需要通过服务端代理
    this.useProxy = getPlatform() === 'web';
  }

  async chat(messages: Message[], options?: ChatOptions): Promise<ChatResponse> {
    const url = this.useProxy
      ? '/api/ollama/chat'  // 服务端代理
      : `${this.baseUrl}/api/chat`;

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: options?.model || 'llama3',
        messages,
        stream: false,
      }),
    });

    return response.json();
  }

  async *chatStream(messages: Message[], options?: ChatOptions): AsyncIterable<ChatChunk> {
    const url = this.useProxy
      ? '/api/ollama/chat'
      : `${this.baseUrl}/api/chat`;

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: options?.model || 'llama3',
        messages,
        stream: true,
      }),
    });

    // 解析流式响应
    const reader = response.body?.getReader();
    if (!reader) throw new Error('No response body');

    const decoder = new TextDecoder();
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const text = decoder.decode(value);
      const lines = text.split('\n').filter(Boolean);

      for (const line of lines) {
        const data = JSON.parse(line);
        yield {
          type: 'text',
          content: data.message?.content || '',
        };
      }
    }
  }
}
```

### Web 端代理路由

```typescript
// apps/web/src/app/api/ollama/chat/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  const body = await request.json();
  const ollamaUrl = process.env.OLLAMA_URL || 'http://localhost:11434';

  const response = await fetch(`${ollamaUrl}/api/chat`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });

  if (body.stream) {
    // 转发流式响应
    return new NextResponse(response.body, {
      headers: { 'Content-Type': 'application/x-ndjson' },
    });
  }

  const data = await response.json();
  return NextResponse.json(data);
}
```

### Desktop 端直连

Desktop 端可以直接调用本地 Ollama，无需代理：

```typescript
// 在 Desktop 环境下，OllamaProvider 的 useProxy 为 false
// 直接请求 http://localhost:11434
```

---

## IPC 通信设计

### Preload 脚本

```typescript
// apps/desktop/electron/preload.ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  // 平台标识
  platform: 'desktop',

  // 数据库路径
  getDbPath: () => ipcRenderer.invoke('db:getPath'),

  // Keychain 操作
  keychain: {
    get: (provider: string) => ipcRenderer.invoke('keychain:get', provider),
    set: (provider: string, key: string) =>
      ipcRenderer.invoke('keychain:set', provider, key),
    delete: (provider: string) => ipcRenderer.invoke('keychain:delete', provider),
    list: () => ipcRenderer.invoke('keychain:list'),
  },

  // 文件系统（后期知识库用）
  fs: {
    readFile: (path: string) => ipcRenderer.invoke('fs:readFile', path),
    writeFile: (path: string, data: string) =>
      ipcRenderer.invoke('fs:writeFile', path, data),
    selectFile: (options: OpenDialogOptions) =>
      ipcRenderer.invoke('fs:selectFile', options),
  },

  // 窗口控制
  window: {
    minimize: () => ipcRenderer.send('window:minimize'),
    maximize: () => ipcRenderer.send('window:maximize'),
    close: () => ipcRenderer.send('window:close'),
  },
});
```

### 类型声明

```typescript
// packages/shared/src/types/electron.d.ts
interface ElectronAPI {
  platform: 'desktop';
  getDbPath: () => Promise<string>;
  keychain: {
    get: (provider: string) => Promise<string | null>;
    set: (provider: string, key: string) => Promise<void>;
    delete: (provider: string) => Promise<void>;
    list: () => Promise<string[]>;
  };
  fs: {
    readFile: (path: string) => Promise<string>;
    writeFile: (path: string, data: string) => Promise<void>;
    selectFile: (options: OpenDialogOptions) => Promise<string[] | null>;
  };
  window: {
    minimize: () => void;
    maximize: () => void;
    close: () => void;
  };
}

declare global {
  interface Window {
    electronAPI?: ElectronAPI;
  }
}
```

---

## 环境变量

### Web 端

```bash
# .env.local (Web)
DATABASE_URL=postgresql://user:pass@localhost:5432/prismax
ENCRYPTION_KEY=your-32-byte-hex-key
OLLAMA_URL=http://localhost:11434
```

### Desktop 端

```bash
# Desktop 端大部分配置通过 electron-store 管理
# 敏感信息通过系统 Keychain 存储
```

---

## 总结

| 模块 | Web | Desktop |
|------|-----|---------|
| 数据库 | PostgreSQL | SQLite |
| API Key 存储 | 加密存数据库 | 系统 Keychain |
| Ollama | 服务端代理 | 直连 |
| 文件系统 | 服务端处理 | IPC 调用主进程 |
| 渲染层 | Next.js | 复用 Web |
